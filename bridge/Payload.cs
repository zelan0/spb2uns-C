// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: sparkplug_b.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
using Google.Protobuf;
using Google.Protobuf.Reflection;
using System;
using System.Collections.Generic;

namespace BridgePayload
{
    public sealed partial class Payload : IMessage<Payload>
    {
        private static readonly MessageParser<Payload> _parser = new MessageParser<Payload>(() => new Payload());
        public static MessageParser<Payload> Parser { get { return _parser; } }

        // *** Lägg till denna statiska Descriptor ***
        public static MessageDescriptor Descriptor
        {
            get { throw new NotImplementedException("Descriptor is not implemented in this manual class."); }
        }

        // *** Detta krävs för IMessage-implementering ***
        MessageDescriptor IMessage.Descriptor => Descriptor;

        public List<Metric> Metrics { get; } = new List<Metric>();
        public long Timestamp { get; set; }

        // ... Lägg till resterande fält enligt .proto, men Metrics räcker ofta för grundfunktion.

        public Payload() { }
        public Payload(Payload other) : this()
        {
            foreach (var m in other.Metrics) Metrics.Add(m.Clone());
        }

        public Payload Clone() => new Payload(this);

        public void MergeFrom(CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    case 10: // field 1: repeated Metric
                        Metric metric = new Metric();
                        input.ReadMessage(metric);
                        Metrics.Add(metric);
                        break;

                    case 16: // field 2: int64 timestamp
                        Timestamp = input.ReadInt64();
                        break;

                    default:
                        input.SkipLastField();
                        break;
                }
            }
        }

        public void MergeFrom(Payload other)
        {
            foreach (var m in other.Metrics) Metrics.Add(m.Clone());
        }

        public void WriteTo(CodedOutputStream output)
        {
            foreach (var m in Metrics)
            {
                output.WriteRawTag(10);
                output.WriteMessage(m);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            foreach (var m in Metrics)
            {
                size += 1 + CodedOutputStream.ComputeMessageSize(m);
            }
            return size;
        }

        public bool Equals(Payload other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;
            // Korrigera till sekvensjämförelse:
            if (this.Metrics.Count != other.Metrics.Count) return false;
            for (int i = 0; i < this.Metrics.Count; i++)
                if (!this.Metrics[i].Equals(other.Metrics[i])) return false;
            return true;
        }

        public override bool Equals(object obj) => Equals(obj as Payload);
        public override int GetHashCode()
        {
            int hash = 17;
            foreach (var m in Metrics)
                hash = hash * 31 + m.GetHashCode();
            return hash;
        }
    }
}
